package config

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"

	"bufio"
	"github.com/pkg/errors"
	"time"
)

// FIXME(vdemeester) Handle header detection and force overidding (with backup ?)

const (
	headerPrefix = "# Autogenerated from peg at "
)

// File represents a config file to be built from a list of sources
type File struct {
	Target    string
	SourceDir string
	Logger    logger
}

type logger interface {
	Printf(format string, a ...interface{}) (n int, err error)
}

type fmtLogger struct{}

func (l fmtLogger) Printf(format string, a ...interface{}) (n int, err error) {
	return fmt.Printf(format, a...)
}

// NewFile creates a File from target and sourceDir
func NewFile(target, sourceDir string) *File {
	return &File{
		Target:    target,
		SourceDir: sourceDir,
		Logger:    fmtLogger{},
	}
}

// Rebuild validate sources and target and overwrite the target with the content
// of the sources appended.
func (f *File) Rebuild() error {
	if err := f.Validate(); err != nil {
		return err
	}
	if err := f.removeTarget(); err != nil {
		return err
	}

	target, err := os.Create(f.Target)
	if err != nil {
		return errors.Wrapf(err, "couldn't create %s file", f.Target)
	}
	defer target.Close()
	files, err := ioutil.ReadDir(f.SourceDir)
	if err != nil {
		return errors.Wrapf(err, "couldn't list files of %s", f.SourceDir)
	}

	targetWriter := bufio.NewWriter(target)
	targetWriter.WriteString(headerPrefix)
	t := time.Now()
	targetWriter.WriteString(t.Format(time.RFC3339))
	targetWriter.WriteString("\n\n")

	for _, file := range files {
		path := filepath.Join(f.SourceDir, file.Name())
		if file.IsDir() {
			f.Logger.Printf("Skipping folder %s\n", path)
			continue
		}
		content, err := ioutil.ReadFile(path)
		if err != nil {
			// FIXME(vdemeester) handle this better by either skipping
			// or writing to final file later
			return err
		}
		targetWriter.WriteString("\n")
		targetWriter.WriteString(fmt.Sprintf("# Appending %s\n", path))
		targetWriter.WriteString(string(content))
		targetWriter.WriteString("\n")

	}
	return targetWriter.Flush()
}

func (f *File) removeTarget() error {
	_, err := os.Stat(f.Target)
	if os.IsNotExist(err) {
		// The target file does not exists, but we know its parent does
		return nil
	}
	return os.Remove(f.Target)
}

// Validate makes sure source folder exists and that the target file can be
// created
func (f *File) Validate() error {
	if err := f.validateTarget(); err != nil {
		return err
	}
	return f.validateSourceDir()
}

func (f *File) validateSourceDir() error {
	fi, err := os.Stat(f.SourceDir)
	if err != nil {
		return errors.Wrapf(err, "couldn't validate source folder: %s", f.SourceDir)
	}
	if !fi.IsDir() {
		return errors.Errorf("%s is a file, should be a folder", f.SourceDir)
	}
	return nil
}

func (f *File) validateTarget() error {
	targetDir := filepath.Dir(f.Target)
	_, err := os.Stat(targetDir)
	if err != nil {
		return errors.Wrapf(err, "couldn't validate target file: %s", f.Target)
	}
	fi, err := os.Stat(f.Target)
	if os.IsNotExist(err) {
		// The target file does not exists, but we know its parent does
		return nil
	}
	if fi.IsDir() {
		return errors.Errorf("%s is a folder, should be either a file or non present", f.Target)
	}
	if fi.Mode()&os.ModeSymlink != 0 {
		return errors.Errorf("%s is a symlink", f.Target)
	}
	return err
}
